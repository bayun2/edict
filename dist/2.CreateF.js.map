{"version":3,"sources":["webpack:///2.CreateF.js","webpack:///./~/url-parse/index.js?8de2","webpack:///./~/querystringify/index.js?fabd","webpack:///./~/requires-port/index.js?2f61","webpack:///./~/url-parse/lolcation.js?35a3","webpack:///./src/routes/CreateF/components/index.js"],"names":["webpackJsonp","12","module","exports","__webpack_require__","extractProtocol","address","match","protocolre","exec","protocol","toLowerCase","slashes","rest","resolve","relative","base","path","split","slice","concat","i","length","last","unshift","up","splice","push","join","URL","location","parser","this","extracted","parse","instruction","index","key","instructions","rules","type","url","qs","lolcation","indexOf","query","pathname","charAt","required","port","host","hostname","username","password","auth","origin","href","toString","NaN","undefined","prototype","set","part","value","fn","test","pop","ins","stringify","result","hash","21","querystring","decodeURIComponent","querystringify","obj","prefix","pairs","has","call","encodeURIComponent","Object","hasOwnProperty","26","27","global","ignore","loc","finaldestination","unescape","134","_interopRequireWildcard","__esModule","newObj","default","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","descriptor","defineProperty","protoProps","staticProps","_react","_react2","_reactRouter","ReactRouter","_urlParse","browserHistory","Link","CreateD","_React$Component","_this","getPrototypeOf","funcName","forEach","bind","reply","_this2","fetch","window","apiPath","apiSuffix","credentials","method","headers","Content-type","body","msg","msgId","then","response","json","setState","image","shareUrl","addParam","catch","_this3","replyEdict","createElement","className","src","curImage","onClick","refuse","Component","defaultProps","propTypes","PropTypes","func","string","headimgurl","nickname","openId","number","sourceHeadimgurl","sourceMsg","sourceNickName","sourceOpenId","status"],"mappings":"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","file":"2.CreateF.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 12:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar required = __webpack_require__(26)\n\t  , lolcation = __webpack_require__(27)\n\t  , qs = __webpack_require__(21)\n\t  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i;\n\t\n\t/**\n\t * These are the parse rules for the URL parser, it informs the parser\n\t * about:\n\t *\n\t * 0. The char it Needs to parse, if it's a string it should be done using\n\t *    indexOf, RegExp using exec and NaN means set as current value.\n\t * 1. The property we should set when parsing this value.\n\t * 2. Indication if it's backwards or forward parsing, when set as number it's\n\t *    the value of extra chars that should be split off.\n\t * 3. Inherit from location if non existing in the parser.\n\t * 4. `toLowerCase` the resulting value.\n\t */\n\tvar rules = [\n\t  ['#', 'hash'],                        // Extract from the back.\n\t  ['?', 'query'],                       // Extract from the back.\n\t  ['/', 'pathname'],                    // Extract from the back.\n\t  ['@', 'auth', 1],                     // Extract from the front.\n\t  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n\t  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n\t  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n\t];\n\t\n\t/**\n\t * @typedef ProtocolExtract\n\t * @type Object\n\t * @property {String} protocol Protocol matched in the URL, in lowercase.\n\t * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n\t * @property {String} rest Rest of the URL that is not part of the protocol.\n\t */\n\t\n\t/**\n\t * Extract protocol information from a URL with/without double slash (\"//\").\n\t *\n\t * @param {String} address URL we want to extract from.\n\t * @return {ProtocolExtract} Extracted information.\n\t * @api private\n\t */\n\tfunction extractProtocol(address) {\n\t  var match = protocolre.exec(address);\n\t\n\t  return {\n\t    protocol: match[1] ? match[1].toLowerCase() : '',\n\t    slashes: !!match[2],\n\t    rest: match[3]\n\t  };\n\t}\n\t\n\t/**\n\t * Resolve a relative URL pathname against a base URL pathname.\n\t *\n\t * @param {String} relative Pathname of the relative URL.\n\t * @param {String} base Pathname of the base URL.\n\t * @return {String} Resolved pathname.\n\t * @api private\n\t */\n\tfunction resolve(relative, base) {\n\t  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n\t    , i = path.length\n\t    , last = path[i - 1]\n\t    , unshift = false\n\t    , up = 0;\n\t\n\t  while (i--) {\n\t    if (path[i] === '.') {\n\t      path.splice(i, 1);\n\t    } else if (path[i] === '..') {\n\t      path.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      if (i === 0) unshift = true;\n\t      path.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  if (unshift) path.unshift('');\n\t  if (last === '.' || last === '..') path.push('');\n\t\n\t  return path.join('/');\n\t}\n\t\n\t/**\n\t * The actual URL instance. Instead of returning an object we've opted-in to\n\t * create an actual constructor as it's much more memory efficient and\n\t * faster and it pleases my OCD.\n\t *\n\t * @constructor\n\t * @param {String} address URL we want to parse.\n\t * @param {Object|String} location Location defaults for relative paths.\n\t * @param {Boolean|Function} parser Parser for the query string.\n\t * @api public\n\t */\n\tfunction URL(address, location, parser) {\n\t  if (!(this instanceof URL)) {\n\t    return new URL(address, location, parser);\n\t  }\n\t\n\t  var relative, extracted, parse, instruction, index, key\n\t    , instructions = rules.slice()\n\t    , type = typeof location\n\t    , url = this\n\t    , i = 0;\n\t\n\t  //\n\t  // The following if statements allows this module two have compatibility with\n\t  // 2 different API:\n\t  //\n\t  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n\t  //    where the boolean indicates that the query string should also be parsed.\n\t  //\n\t  // 2. The `URL` interface of the browser which accepts a URL, object as\n\t  //    arguments. The supplied object will be used as default values / fall-back\n\t  //    for relative paths.\n\t  //\n\t  if ('object' !== type && 'string' !== type) {\n\t    parser = location;\n\t    location = null;\n\t  }\n\t\n\t  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\t\n\t  location = lolcation(location);\n\t\n\t  //\n\t  // Extract protocol information before running the instructions.\n\t  //\n\t  extracted = extractProtocol(address || '');\n\t  relative = !extracted.protocol && !extracted.slashes;\n\t  url.slashes = extracted.slashes || relative && location.slashes;\n\t  url.protocol = extracted.protocol || location.protocol || '';\n\t  address = extracted.rest;\n\t\n\t  //\n\t  // When the authority component is absent the URL starts with a path\n\t  // component.\n\t  //\n\t  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\n\t\n\t  for (; i < instructions.length; i++) {\n\t    instruction = instructions[i];\n\t    parse = instruction[0];\n\t    key = instruction[1];\n\t\n\t    if (parse !== parse) {\n\t      url[key] = address;\n\t    } else if ('string' === typeof parse) {\n\t      if (~(index = address.indexOf(parse))) {\n\t        if ('number' === typeof instruction[2]) {\n\t          url[key] = address.slice(0, index);\n\t          address = address.slice(index + instruction[2]);\n\t        } else {\n\t          url[key] = address.slice(index);\n\t          address = address.slice(0, index);\n\t        }\n\t      }\n\t    } else if (index = parse.exec(address)) {\n\t      url[key] = index[1];\n\t      address = address.slice(0, index.index);\n\t    }\n\t\n\t    url[key] = url[key] || (\n\t      relative && instruction[3] ? location[key] || '' : ''\n\t    );\n\t\n\t    //\n\t    // Hostname, host and protocol should be lowercased so they can be used to\n\t    // create a proper `origin`.\n\t    //\n\t    if (instruction[4]) url[key] = url[key].toLowerCase();\n\t  }\n\t\n\t  //\n\t  // Also parse the supplied query string in to an object. If we're supplied\n\t  // with a custom parser as function use that instead of the default build-in\n\t  // parser.\n\t  //\n\t  if (parser) url.query = parser(url.query);\n\t\n\t  //\n\t  // If the URL is relative, resolve the pathname against the base URL.\n\t  //\n\t  if (\n\t      relative\n\t    && location.slashes\n\t    && url.pathname.charAt(0) !== '/'\n\t    && (url.pathname !== '' || location.pathname !== '')\n\t  ) {\n\t    url.pathname = resolve(url.pathname, location.pathname);\n\t  }\n\t\n\t  //\n\t  // We should not add port numbers if they are already the default port number\n\t  // for a given protocol. As the host also contains the port number we're going\n\t  // override it with the hostname which contains no port number.\n\t  //\n\t  if (!required(url.port, url.protocol)) {\n\t    url.host = url.hostname;\n\t    url.port = '';\n\t  }\n\t\n\t  //\n\t  // Parse down the `auth` for the username and password.\n\t  //\n\t  url.username = url.password = '';\n\t  if (url.auth) {\n\t    instruction = url.auth.split(':');\n\t    url.username = instruction[0] || '';\n\t    url.password = instruction[1] || '';\n\t  }\n\t\n\t  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n\t    ? url.protocol +'//'+ url.host\n\t    : 'null';\n\t\n\t  //\n\t  // The href is just the compiled result.\n\t  //\n\t  url.href = url.toString();\n\t}\n\t\n\t/**\n\t * This is convenience method for changing properties in the URL instance to\n\t * insure that they all propagate correctly.\n\t *\n\t * @param {String} part          Property we need to adjust.\n\t * @param {Mixed} value          The newly assigned value.\n\t * @param {Boolean|Function} fn  When setting the query, it will be the function\n\t *                               used to parse the query.\n\t *                               When setting the protocol, double slash will be\n\t *                               removed from the final url if it is true.\n\t * @returns {URL}\n\t * @api public\n\t */\n\tURL.prototype.set = function set(part, value, fn) {\n\t  var url = this;\n\t\n\t  switch (part) {\n\t    case 'query':\n\t      if ('string' === typeof value && value.length) {\n\t        value = (fn || qs.parse)(value);\n\t      }\n\t\n\t      url[part] = value;\n\t      break;\n\t\n\t    case 'port':\n\t      url[part] = value;\n\t\n\t      if (!required(value, url.protocol)) {\n\t        url.host = url.hostname;\n\t        url[part] = '';\n\t      } else if (value) {\n\t        url.host = url.hostname +':'+ value;\n\t      }\n\t\n\t      break;\n\t\n\t    case 'hostname':\n\t      url[part] = value;\n\t\n\t      if (url.port) value += ':'+ url.port;\n\t      url.host = value;\n\t      break;\n\t\n\t    case 'host':\n\t      url[part] = value;\n\t\n\t      if (/:\\d+$/.test(value)) {\n\t        value = value.split(':');\n\t        url.port = value.pop();\n\t        url.hostname = value.join(':');\n\t      } else {\n\t        url.hostname = value;\n\t        url.port = '';\n\t      }\n\t\n\t      break;\n\t\n\t    case 'protocol':\n\t      url.protocol = value.toLowerCase();\n\t      url.slashes = !fn;\n\t      break;\n\t\n\t    case 'pathname':\n\t      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\n\t\n\t      break;\n\t\n\t    default:\n\t      url[part] = value;\n\t  }\n\t\n\t  for (var i = 0; i < rules.length; i++) {\n\t    var ins = rules[i];\n\t\n\t    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n\t  }\n\t\n\t  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n\t    ? url.protocol +'//'+ url.host\n\t    : 'null';\n\t\n\t  url.href = url.toString();\n\t\n\t  return url;\n\t};\n\t\n\t/**\n\t * Transform the properties back in to a valid and full URL string.\n\t *\n\t * @param {Function} stringify Optional query stringify function.\n\t * @returns {String}\n\t * @api public\n\t */\n\tURL.prototype.toString = function toString(stringify) {\n\t  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\t\n\t  var query\n\t    , url = this\n\t    , protocol = url.protocol;\n\t\n\t  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\t\n\t  var result = protocol + (url.slashes ? '//' : '');\n\t\n\t  if (url.username) {\n\t    result += url.username;\n\t    if (url.password) result += ':'+ url.password;\n\t    result += '@';\n\t  }\n\t\n\t  result += url.host + url.pathname;\n\t\n\t  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n\t  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\t\n\t  if (url.hash) result += url.hash;\n\t\n\t  return result;\n\t};\n\t\n\t//\n\t// Expose the URL parser and some additional properties that might be useful for\n\t// others or testing.\n\t//\n\tURL.extractProtocol = extractProtocol;\n\tURL.location = lolcation;\n\tURL.qs = qs;\n\t\n\tmodule.exports = URL;\n\n\n/***/ },\n\n/***/ 21:\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * Simple query string parser.\n\t *\n\t * @param {String} query The query string that needs to be parsed.\n\t * @returns {Object}\n\t * @api public\n\t */\n\tfunction querystring(query) {\n\t  var parser = /([^=?&]+)=?([^&]*)/g\n\t    , result = {}\n\t    , part;\n\t\n\t  //\n\t  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n\t  // the lastIndex property so we can continue executing this loop until we've\n\t  // parsed all results.\n\t  //\n\t  for (;\n\t    part = parser.exec(query);\n\t    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n\t  );\n\t\n\t  return result;\n\t}\n\t\n\t/**\n\t * Transform a query string to an object.\n\t *\n\t * @param {Object} obj Object that should be transformed.\n\t * @param {String} prefix Optional prefix.\n\t * @returns {String}\n\t * @api public\n\t */\n\tfunction querystringify(obj, prefix) {\n\t  prefix = prefix || '';\n\t\n\t  var pairs = [];\n\t\n\t  //\n\t  // Optionally prefix with a '?' if needed\n\t  //\n\t  if ('string' !== typeof prefix) prefix = '?';\n\t\n\t  for (var key in obj) {\n\t    if (has.call(obj, key)) {\n\t      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n\t    }\n\t  }\n\t\n\t  return pairs.length ? prefix + pairs.join('&') : '';\n\t}\n\t\n\t//\n\t// Expose the module.\n\t//\n\texports.stringify = querystringify;\n\texports.parse = querystring;\n\n\n/***/ },\n\n/***/ 26:\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Check if we're required to add a port number.\n\t *\n\t * @see https://url.spec.whatwg.org/#default-port\n\t * @param {Number|String} port Port number we need to check\n\t * @param {String} protocol Protocol we need to check against.\n\t * @returns {Boolean} Is it a default port for the given protocol\n\t * @api private\n\t */\n\tmodule.exports = function required(port, protocol) {\n\t  protocol = protocol.split(':')[0];\n\t  port = +port;\n\t\n\t  if (!port) return false;\n\t\n\t  switch (protocol) {\n\t    case 'http':\n\t    case 'ws':\n\t    return port !== 80;\n\t\n\t    case 'https':\n\t    case 'wss':\n\t    return port !== 443;\n\t\n\t    case 'ftp':\n\t    return port !== 21;\n\t\n\t    case 'gopher':\n\t    return port !== 70;\n\t\n\t    case 'file':\n\t    return false;\n\t  }\n\t\n\t  return port !== 0;\n\t};\n\n\n/***/ },\n\n/***/ 27:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\t\n\t/**\n\t * These properties should not be copied or inherited from. This is only needed\n\t * for all non blob URL's as a blob URL does not include a hash, only the\n\t * origin.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tvar ignore = { hash: 1, query: 1 }\n\t  , URL;\n\t\n\t/**\n\t * The location object differs when your code is loaded through a normal page,\n\t * Worker or through a worker using a blob. And with the blobble begins the\n\t * trouble as the location object will contain the URL of the blob, not the\n\t * location of the page where our code is loaded in. The actual origin is\n\t * encoded in the `pathname` so we can thankfully generate a good \"default\"\n\t * location from it so we can generate proper relative URL's again.\n\t *\n\t * @param {Object|String} loc Optional default location object.\n\t * @returns {Object} lolcation object.\n\t * @api public\n\t */\n\tmodule.exports = function lolcation(loc) {\n\t  loc = loc || global.location || {};\n\t  URL = URL || __webpack_require__(12);\n\t\n\t  var finaldestination = {}\n\t    , type = typeof loc\n\t    , key;\n\t\n\t  if ('blob:' === loc.protocol) {\n\t    finaldestination = new URL(unescape(loc.pathname), {});\n\t  } else if ('string' === type) {\n\t    finaldestination = new URL(loc, {});\n\t    for (key in ignore) delete finaldestination[key];\n\t  } else if ('object' === type) {\n\t    for (key in loc) {\n\t      if (key in ignore) continue;\n\t      finaldestination[key] = loc[key];\n\t    }\n\t\n\t    if (finaldestination.slashes === undefined) {\n\t      finaldestination.slashes = slashes.test(loc.href);\n\t    }\n\t  }\n\t\n\t  return finaldestination;\n\t};\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 134:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _reactRouter = __webpack_require__(23);\n\t\n\tvar ReactRouter = _interopRequireWildcard(_reactRouter);\n\t\n\tvar _urlParse = __webpack_require__(12);\n\t\n\tvar _urlParse2 = _interopRequireDefault(_urlParse);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Link = ReactRouter.Link,\n\t    browserHistory = ReactRouter.browserHistory;\n\t\n\tvar CreateD = function (_React$Component) {\n\t  _inherits(CreateD, _React$Component);\n\t\n\t  function CreateD(props) {\n\t    _classCallCheck(this, CreateD);\n\t\n\t    var _this = _possibleConstructorReturn(this, (CreateD.__proto__ || Object.getPrototypeOf(CreateD)).call(this, props));\n\t\n\t    _this.funcName = ['reply', 'refuse', 'replyEdict'];\n\t    _this.funcName.forEach(function (funcName) {\n\t      _this[funcName] = _this[funcName].bind(_this);\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  _createClass(CreateD, [{\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {}\n\t  }, {\n\t    key: 'componentWillUnmount',\n\t    value: function componentWillUnmount() {}\n\t  }, {\n\t    key: 'replyEdict',\n\t    value: function replyEdict(reply) {\n\t      var _this2 = this;\n\t\n\t      var self = this;\n\t      fetch(window.apiPath + '/add' + window.apiSuffix, {\n\t        credentials: 'include',\n\t        method: 'POST',\n\t        headers: {\n\t          'Content-type': 'application/x-www-form-urlencoded;charset=UTF-8'\n\t        },\n\t        body: 'reply=' + reply + '&msg=' + self.props.msg + '&msgId=' + self.props.msgId\n\t      }).then(function (response) {\n\t        return response.json();\n\t      }).then(function (json) {\n\t        self.props.setState({\n\t          image: json.image,\n\t          shareUrl: json.shareUrl\n\t        }, function () {\n\t          var url = _this2.props.addParam('created');\n\t          browserHistory.push(url);\n\t        });\n\t      }).catch(function () {});\n\t    }\n\t  }, {\n\t    key: 'refuse',\n\t    value: function refuse() {\n\t      var _this3 = this;\n\t\n\t      this.props.setState({\n\t        reply: 2\n\t      }, function () {\n\t        _this3.replyEdict(2);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'reply',\n\t    value: function reply() {\n\t      var url = this.props.addParam('createb');\n\t      this.props.setState({\n\t        reply: 1\n\t      }, function () {\n\t        browserHistory.push(url);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      return _react2.default.createElement(\n\t        'div',\n\t        { className: 'replyb picwrap' },\n\t        _react2.default.createElement('img', { className: 'cutpic', src: this.props.curImage }),\n\t        _react2.default.createElement(\n\t          'div',\n\t          { className: 'btngroup' },\n\t          _react2.default.createElement(\n\t            'div',\n\t            { className: 'btn a', onClick: this.reply },\n\t            '\\u590D\\u65E8'\n\t          ),\n\t          _react2.default.createElement(\n\t            'div',\n\t            { className: 'btn b', onClick: this.refuse },\n\t            '\\u6297\\u65E8'\n\t          )\n\t        )\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return CreateD;\n\t}(_react2.default.Component);\n\t\n\tCreateD.defaultProps = {};\n\t\n\tCreateD.propTypes = {\n\t  addParam: _react2.default.PropTypes.func,\n\t  curImage: _react2.default.PropTypes.string,\n\t  headimgurl: _react2.default.PropTypes.string,\n\t  msg: _react2.default.PropTypes.string,\n\t  msgId: _react2.default.PropTypes.string,\n\t  nickname: _react2.default.PropTypes.string,\n\t  openId: _react2.default.PropTypes.string,\n\t  reply: _react2.default.PropTypes.number,\n\t  setState: _react2.default.PropTypes.func,\n\t  sourceHeadimgurl: _react2.default.PropTypes.string,\n\t  sourceMsg: _react2.default.PropTypes.string,\n\t  sourceNickName: _react2.default.PropTypes.string,\n\t  sourceOpenId: _react2.default.PropTypes.string,\n\t  status: _react2.default.PropTypes.string\n\t};\n\t\n\tmodule.exports = CreateD;\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// 2.CreateF.js","'use strict';\n\nvar required = require('requires-port')\n  , lolcation = require('./lolcation')\n  , qs = require('querystringify')\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i;\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @api private\n */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @api private\n */\nfunction resolve(relative, base) {\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL}\n * @api public\n */\nURL.prototype.set = function set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\n\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n};\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nURL.prototype.toString = function toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n};\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nURL.extractProtocol = extractProtocol;\nURL.location = lolcation;\nURL.qs = qs;\n\nmodule.exports = URL;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url-parse/index.js\n// module id = 12\n// module chunks = 1 2 3 4","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/querystringify/index.js\n// module id = 21\n// module chunks = 1 2 3 4","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/requires-port/index.js\n// module id = 26\n// module chunks = 1 2 3 4","'use strict';\n\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 }\n  , URL;\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nmodule.exports = function lolcation(loc) {\n  loc = loc || global.location || {};\n  URL = URL || require('./');\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/url-parse/lolcation.js\n// module id = 27\n// module chunks = 1 2 3 4","import React from 'react';\nimport * as ReactRouter from 'react-router';\nimport UrlParse from 'url-parse';\n\nconst {Link, browserHistory} = ReactRouter;\n\nclass CreateD extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.funcName = ['reply', 'refuse', 'replyEdict'];\n    this.funcName.forEach(funcName => {\n      this[funcName] = this[funcName].bind(this);\n    });\n  }\n\n  componentDidMount() {\n\n  }\n\n  componentWillUnmount() {\n\n  }\n\n  replyEdict(reply) {\n    const self = this;\n    fetch(`${window.apiPath}/add${window.apiSuffix}`, {\n      credentials: 'include',\n      method: 'POST',\n      headers: {\n        'Content-type': 'application/x-www-form-urlencoded;charset=UTF-8'\n      },\n      body: `reply=${reply}&msg=${self.props.msg}&msgId=${self.props.msgId}`\n    })\n      .then(response => response.json())\n      .then(json => {\n        self.props.setState({\n          image: json.image,\n          shareUrl: json.shareUrl\n        }, () => {\n          const url = this.props.addParam('created');\n          browserHistory.push(url);\n        });\n      })\n      .catch(() => {\n\n      });\n  }\n\n  refuse() {\n    this.props.setState({\n      reply: 2\n    }, () => {\n      this.replyEdict(2);\n    });\n  }\n\n  reply() {\n    const url = this.props.addParam('createb');\n    this.props.setState({\n      reply: 1\n    }, () => {\n      browserHistory.push(url);\n    });\n  }\n\n  render() {\n    return (\n        <div className=\"replyb picwrap\">\n          <img className=\"cutpic\" src={this.props.curImage} />\n          <div className=\"btngroup\">\n            <div className=\"btn a\" onClick={this.reply}>复旨</div>\n            <div className=\"btn b\" onClick={this.refuse}>抗旨</div>\n          </div>\n        </div>\n    );\n  }\n}\n\nCreateD.defaultProps = {\n\n};\n\nCreateD.propTypes = {\n  addParam: React.PropTypes.func,\n  curImage: React.PropTypes.string,\n  headimgurl: React.PropTypes.string,\n  msg: React.PropTypes.string,\n  msgId: React.PropTypes.string,\n  nickname: React.PropTypes.string,\n  openId: React.PropTypes.string,\n  reply: React.PropTypes.number,\n  setState: React.PropTypes.func,\n  sourceHeadimgurl: React.PropTypes.string,\n  sourceMsg: React.PropTypes.string,\n  sourceNickName: React.PropTypes.string,\n  sourceOpenId: React.PropTypes.string,\n  status: React.PropTypes.string\n};\n\nmodule.exports = CreateD;\n\n\n\n// WEBPACK FOOTER //\n// ./src/routes/CreateF/components/index.js"],"sourceRoot":""}